(in-package #:org.shirakumo.fraf.wavefront)

(defun serialize-simple (vertices faces target &rest args)
  (let ((mesh (make-instance 'mesh :vertex-data vertices :index-data faces :attributes '(:position)
                                   :name "mesh")))
    (apply #'serialize mesh target args)))

(defgeneric serialize (context target &key material-library-file export-materials if-exists))

(defmethod serialize (context (target (eql :string)) &rest args &key &allow-other-keys)
 (with-output-to-string (target)
   (apply #'serialize context target args)))

(defmethod serialize (context (target string) &rest args &key &allow-other-keys)
 (with-output-to-string (target target)
   (apply #'serialize context target args)))

(defmethod serialize (context (target pathname) &rest args &key (if-exists :error) &allow-other-keys)
 (let ((*default-pathname-defaults* target))
   (with-open-file (target target :direction :output :if-exists if-exists)
     (apply #'serialize context target args))))

(defmethod serialize ((mesh mesh) stream &rest args &key &allow-other-keys)
  (apply #'serialize (combine-meshes mesh) stream args))

(defmethod serialize ((meshes vector) stream &rest args &key &allow-other-keys)
  (apply #'serialize (combine-meshes meshes) stream args))

(defmethod serialize ((context context) (stream stream) &key (material-library-file :create) (export-materials T) if-exists)
  (flet ((f (format &rest args)
           (format stream "~&~?~%" format args)))
    (f "# Generated by cl-wavefront")
    (cond ((and export-materials (< 0 (hash-table-count (materials context))))
           (case material-library-file
             ((NIL)
              (loop for material being the hash-values of (materials context)
                    do (serialize material stream)))
             (:create
              (setf material-library-file (make-pathname :type "mtl" :defaults (pathname stream)))))
           (when material-library-file
             (with-open-file (stream material-library-file :direction :output :if-exists if-exists)
               (loop for material being the hash-values of (materials context)
                     do (serialize material stream)))
             (f "mtllib ~a" (enough-namestring material-library-file (pathname stream)))))
          ((typep material-library-file '(or string pathname))
           (f "mtllib ~a" (etypecase material-library-file
                            (pathname (namestring material-library-file))
                            (string material-library-file)))))
    (loop for i from 0 below (length (vertices context)) by 4
          do (f "v ~f ~f ~f~@[ ~f~]"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (aref (vertices context) (+ i 2))
                (unless (= 1.0 (aref (vertices context) (+ i 3)))
                  (aref (vertices context) (+ i 3)))))
    (loop for i from 0 below (length (normals context)) by 3
          do (f "vn ~f ~f ~f"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (aref (vertices context) (+ i 2))))
    (loop for i from 0 below (length (uvs context)) by 3
          do (f "vt ~f ~f~@[ ~f~]"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (unless (= 0.0 (aref (vertices context) (+ i 3)))
                  (aref (vertices context) (+ i 3)))))
    (let ((group-objects (make-hash-table :test 'eq))
          material)
      (loop with material = NIL
            for object being the hash-values of (objects context)
            do (loop for group being the hash-values of (groups object)
                     do (setf (gethash group group-objects) object)))
      (loop for group being the hash-values of (groups context)
            for object = (gethash group group-objects)
            do (when object
                 (f "o~@[ ~a~]" (name object)))
               (f "g~@[ ~a~]" (name group))
               (when (lod group) (f "lod ~a" (lod group)))
               (loop for face across (faces group)
                     do (unless (eq material (material face))
                          (f "usemtl ~a" (name (material face))))
                        (format stream "~&f")
                        (loop for i from 0 below (length (vertices face))
                              for v = (aref (vertices face) i)
                              for u = (when (< i (length (uvs face))) (aref (uvs face) i))
                              for n = (when (< i (length (normals face))) (aref (normals face) i))
                              do (if n
                                     (format stream " ~d/~@[~d~]/~d" v u n)
                                     (format stream " ~d~@[/~d~]" v u)))
                        (terpri stream))))))

(defmethod serialize ((material material) (stream stream) &rest args &key &allow-other-keys)
  )
