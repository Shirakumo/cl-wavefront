(in-package #:org.shirakumo.fraf.wavefront)

(defun serialize-simple (vertices faces target &rest args)
  (let ((mesh (make-instance 'mesh :vertex-data vertices :index-data faces :attributes '(:position)
                                   :name "mesh")))
    (apply #'serialize mesh target args)))

(defgeneric serialize (context target &key material-library-file export-materials if-exists))

(defmethod serialize (context (target (eql :string)) &rest args &key &allow-other-keys)
  (with-output-to-string (target)
    (apply #'serialize context target args)))

(defmethod serialize (context (target string) &rest args &key &allow-other-keys)
  (apply #'serialize context (pathname target) args))

(defmethod serialize (context (target pathname) &rest args &key (if-exists :error) &allow-other-keys)
  (let ((*default-pathname-defaults* target))
    (with-open-file (target target :direction :output :if-exists if-exists)
      (apply #'serialize context target args))
    target))

(defmethod serialize ((mesh mesh) stream &rest args &key &allow-other-keys)
  (apply #'serialize (combine-meshes mesh) stream args))

(defmethod serialize ((meshes vector) stream &rest args &key &allow-other-keys)
  (apply #'serialize (combine-meshes meshes) stream args))

(defmethod serialize ((meshes list) stream &rest args &key &allow-other-keys)
  (apply #'serialize (combine-meshes meshes) stream args))

(defmethod serialize ((context context) (stream stream) &key (material-library-file :create) (export-materials T) if-exists)
  (flet ((f (format &rest args)
           (format stream "~&~?~%" format args)))
    (f "# Generated by cl-wavefront")
    (cond ((and export-materials (< 0 (hash-table-count (materials context))))
           (case material-library-file
             ((NIL)
              (loop for material being the hash-values of (materials context)
                    do (serialize material stream)))
             (:create
              (setf material-library-file (make-pathname :type "mtl" :defaults (pathname stream)))))
           (when material-library-file
             (with-open-file (stream material-library-file :direction :output :if-exists if-exists)
               (loop for material being the hash-values of (materials context)
                     do (serialize material stream)))
             (f "mtllib ~a" (enough-namestring material-library-file (pathname stream)))))
          ((typep material-library-file '(or string pathname))
           (f "mtllib ~a" (etypecase material-library-file
                            (pathname (namestring material-library-file))
                            (string material-library-file)))))
    (loop for i from 0 below (length (vertices context)) by 4
          do (f "v ~f ~f ~f~@[ ~f~]"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (aref (vertices context) (+ i 2))
                (unless (= 1.0 (aref (vertices context) (+ i 3)))
                  (aref (vertices context) (+ i 3)))))
    (loop for i from 0 below (length (normals context)) by 3
          do (f "vn ~f ~f ~f"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (aref (vertices context) (+ i 2))))
    (loop for i from 0 below (length (uvs context)) by 3
          do (f "vt ~f ~f~@[ ~f~]"
                (aref (vertices context) (+ i 0))
                (aref (vertices context) (+ i 1))
                (unless (= 0.0 (aref (vertices context) (+ i 3)))
                  (aref (vertices context) (+ i 3)))))
    (let ((group-objects (make-hash-table :test 'eq))
          material)
      (loop with material = NIL
            for object being the hash-values of (objects context)
            do (loop for group being the hash-values of (groups object)
                     do (setf (gethash group group-objects) object)))
      (loop for group being the hash-values of (groups context)
            for object = (gethash group group-objects)
            do (when object
                 (f "o~@[ ~a~]" (name object)))
               (f "g~@[ ~a~]" (name group))
               (when (lod group) (f "lod ~a" (lod group)))
               (loop for face across (faces group)
                     do (unless (eq material (material face))
                          (f "usemtl ~a" (name (material face)))
                          (setf material (material face)))
                        (format stream "~&f")
                        (loop for i from 0 below (length (vertices face))
                              for v = (1+ (aref (vertices face) i))
                              for u = (when (< i (length (uvs face))) (1+ (aref (uvs face) i)))
                              for n = (when (< i (length (normals face))) (1+ (aref (normals face) i)))
                              do (if n
                                     (format stream " ~d/~@[~d~]/~d" v u n)
                                     (format stream " ~d~@[/~d~]" v u)))
                        (terpri stream))))))

(defmethod serialize ((material material) (stream stream) &key &allow-other-keys)
  (flet ((f (format &rest args)
           (format stream "~&~?~%" format args)))
    (f "newmtl~@[ ~a~]" (name material))
    (unless (= 2 (illumination-model material))
      (f "illum ~d" (illumination-model material)))
    (unless (equal #(0.0 0.0 0.0) (ambient-factor material))
      (f "Ka ~f ~f ~f" (aref (ambient-factor material) 0) (aref (ambient-factor material) 1) (aref (ambient-factor material) 2)))
    (unless (equal #(0.0 0.0 0.0) (diffuse-factor material))
      (f "Kd ~f ~f ~f" (aref (diffuse-factor material) 0) (aref (diffuse-factor material) 1) (aref (diffuse-factor material) 2)))
    (unless (equal #(0.0 0.0 0.0) (specular-factor material))
      (f "Ks ~f ~f ~f" (aref (specular-factor material) 0) (aref (specular-factor material) 1) (aref (specular-factor material) 2)))
    (unless (= 1.0 (specular-exponent material))
      (f "Ns ~f" (specular-exponent material)))
    (unless (= 0.0 (transmission-factor material))
      (f "Tr ~f" (transmission-factor material)))
    (unless (equal #(0.0 0.0 0.0) (transmission-filter material))
      (f "Tf ~f ~f ~f" (aref (transmission-filter material) 0) (aref (transmission-filter material) 1) (aref (transmission-filter material) 2)))
    (unless (= 1.0 (refractive-index material))
      (f "Ni ~f" (refractive-index material)))
    (unless (= 1.0 (roughness-factor material))
      (f "Pr ~f" (roughness-factor material)))
    (unless (= 1.0 (metallic-factor material))
      (f "Pm ~f" (metallic-factor material)))
    (unless (= 1.0 (sheen-factor material))
      (f "Ps ~f" (sheen-factor material)))
    (unless (equal #(0.0 0.0 0.0) (emissive-factor material))
      (f "Ke ~f ~f ~f" (aref (emissive-factor material) 0) (aref (emissive-factor material) 1) (aref (emissive-factor material) 2)))
    (flet ((maybe-map (id slot)
             (when (slot-value material slot)
               (format stream "~&~(~a~)" id)
               (serialize (slot-value material slot) stream)
               (terpri stream))))
      (maybe-map :map_ka 'ambient-map)
      (maybe-map :map_kd 'diffuse-map)
      (maybe-map :map_ks 'specular-map)
      (maybe-map :map_tr 'transmission-map)
      (maybe-map :map_bump 'bump-map)
      (maybe-map :bump 'bump-map)
      (maybe-map :disp 'displacement-map)
      (maybe-map :decal 'stencil-map)
      (maybe-map :map_pr 'roughness-map)
      (maybe-map :map_pm 'metallic-map)
      (maybe-map :map_ps 'sheen-map)
      (maybe-map :map_ke 'emissive-map)
      (maybe-map :map_rma 'rough-metal-occlusion-map)
      (maybe-map :map_orm 'rough-metal-occlusion-map)
      (maybe-map :norm 'normal-map))))

(defmethod serialize ((map texture-map) (stream stream) &key &allow-other-keys)
  (flet ((f (format &rest args)
           (format stream " ~?" format args)))
    (unless (blend-u map)
      (f "-blendu off"))
    (unless (blend-v map)
      (f "-blendv off"))
    (unless (= 1.0 (boost map))
      (f "-boost ~f" (boost map)))
    (unless (equal #(0.0 0.0 0.0) (origin map))
      (f "-o ~f ~f ~f" (aref (origin map) 0) (aref (origin map) 1) (aref (origin map) 2)))
    (unless (equal #(1.0 1.0 1.0) (scale map))
      (f "-s ~f ~f ~f" (aref (scale map) 0) (aref (scale map) 1) (aref (scale map) 2)))
    (unless (equal #(0.0 0.0 0.0) (turbulence map))
      (f "-t ~f ~f ~f" (aref (turbulence map) 0) (aref (turbulence map) 1) (aref (turbulence map) 2)))
    (when (resolution map)
      (f "-texres ~d" (resolution map)))
    (when (clamp map)
      (f "-clamp on"))
    (unless (= 1.0 (multiplier map))
      (f "-bm ~f" (multiplier map)))
    (unless (eql 1 (bump-channel map))
      (f "-imfchan ~a" (bump-channel map)))
    (when (texture-type map)
      (f "-type ~a" (texture-type map)))
    (f "~a" (enough-namestring (file map) *default-pathname-defaults*))))
